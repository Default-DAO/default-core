Design Principles

1. Keep logic tight. Don't cut corners. Keep state where it should exist. 
2. Keep code functionality modular. Contracts should be small and state changes basic.

... Implement pure function design standards? No side effects, everything is coded functional style?
--> Are there contract size limitations to this style of coding?y


Contract Architecture Convention/Style Guidelines:

Our contract architecture is broken down into different pieces:

1. State Contracts -> state
2. Application Contracts -> business logic
3. Interfaces -> defining state + application contracts for external use
4. Operator.sol -> this is the "main" contract that aggregates and forwards calls to other contracts
                   that the DAO multisig calls to execute certain operational functions like incrementEpoch() and bulkTransfer()

-----

1. State Contracts
- These contracts are immutable and represent source of truth data for the DAO.
- State Contracts are always Ownable, and they are owned by the application contracts that can change state
    - In the future if there are multiple applications that can change state, upgrade the modifier library so that
    - there can be an array of owners (whitelisted applications)
- If we want to improve state we should extend existing storage, keeping state immutability is critical.

2. Application Contracts
- These contracts can be rotated and upgraded. During upgrade, change the ownership of the state contracts
  to the application contracts

3. Interfaces
- Define reads, writes, and events separately for the Interfaces

4. Operator
- Defines the "era" or "main version" of the DAO protocol. E.g. Default v0.1 or Default v1.0 (for major releases)


-----

100% Checks - Effects - Interactions design pattern

checks  = business logic validations
effects = persistent state changes internal to the contract
interactions = external contract calls

-----

- parameter variables have trailing underscores: paramArg_
- interval state variables have leading underscores: _privateState

This is just to have some comptability with OpenZeppelin conventions

-----

Smart contracts are distributed systems using message passing, but through the VM.
It's an event-driven system, you can't think object oriented. Each transaction is an event
composed of multiple messages being passed in a certain order (contract call flow).

This is why it's always good to call external contracts last â€” you want to do all your state changes first
before you leave the system.

-----

State SHOULD be immutable. There should be a very atomic, functional-style programming applied to smart contracts.
SO many bugs/hacks come from shit people are doing with state that they shouldn't. So much admin managed state,
side effects, and similar things causing security issues. 

-----

Upgrades/Proxies:

The way that people are thinking about Proxies are so whack. There should be a single Proxy
contract serving as an api gateway and everything else is just a read/query layer than can be redirected by the gateway.
People trying to forward calls via delegate call through the state contract are insane.
Diamond standard as a standard makes sense but the naming/branding around it is just ridiculous.

Use a CQRS style contract architecture (separate reads/writes). Idk what I'm talking about.

----

TODO:
- Recreate contracts with correct state + new file organization system.


IDEA:
- on launch of contracts, start at epoch 1. Fresh start. New DAO from beginning. Reset issuance.
- give all contributors/depositors tokens earned in the form of sDNT.
- let depositors decide: deposit in contract to earn sDNT, or walk away from the table full refund no questions asked + earned sDNT.
- set higher withdraw fee -> 20%? create locking mechanism for multipliers? 6mo, 12mo, 18mo?

