Design Principles

1. Keep logic tight. Don't cut corners. Keep state where it should exist. 
2. Keep code functionality modular. Contracts should be small and state changes basic.

... Implement pure function design standards? No side effects, everything is coded functional style?
--> Are there contract size limitations to this style of coding?y


Contract Architecture Convention/Style Guidelines:

Our contract architecture is broken down into different pieces:

1. State Contracts -> state
2. Application Contracts -> business logic
3. Interfaces -> defining state + application contracts for external use
4. Operator.sol -> this is the "main" contract that aggregates and forwards calls to other contracts
                   that the DAO multisig calls to execute certain operational functions like incrementEpoch() and bulkTransfer()

-----

1. State Contracts
- These contracts are immutable and represent source of truth data for the DAO.
- State Contracts are always Ownable, and they are owned by the application contracts that can change state
    - In the future if there are multiple applications that can change state, upgrade the modifier library so that
    - there can be an array of owners (whitelisted applications)
- If we want to improve state we should extend existing storage, keeping state immutability is critical.

- State contracts have PUBLIC variables and WRITE functions only.
  - public variables -> return
  - public functions -> no return
- Complex views (queries) are created in the app contracts by reading from the state variables.
- no events (events are for indexing instances of application logic execution)

2. Application Contracts
- These contracts can be rotated and upgraded. During upgrade, change the ownership of the state contracts
  to the application contracts
- These contracts are versioned
- State contracts are underscore Capitalized & always _private
- Events are defined on applications

3. Interfaces
- State Interfaces: Define reads & writes for the state contract.
  - reads: MUST BE Public VARIABLES
  - writes: MUST BE SIMPLE ATOMIC TRANSACTIONS (NO BUSINESS LOGIC)

- App Interfaces: Define reads & writes for the logic & events.

4. Operator
- Defines the "era" or "main version" of the DAO protocol. E.g. Default v0.1 or Default v1.0 (for major releases)


-----

importing priority:

 import library (state vs. app) --> first thing devs should think about: is this a state contract or app contract?
 import outside interfaces (@openzeppelin/IERC.sol)
 import protocol/interface
 import outside modules (@openzeppelin/ERC20.sol)

declaring priority: declare protocol/interface, declare contract type (app/state)

-----

100% Checks - Effects - Interactions design pattern

checks  = business logic validations
effects = persistent state changes internal to the contract
interactions = external contract calls

-----

- parameter variables have trailing underscores: paramArg_
- interval state variables have leading underscores: _privateState

This is just to have some comptability with OpenZeppelin conventions

-----

Smart contracts are distributed systems using message passing, but through the VM.
It's an event-driven system, you can't think object oriented. Each transaction is an event
composed of multiple messages being passed in a certain order (contract call flow).

This is why it's always good to call external contracts last â€” you want to do all your state changes first
before you leave the system.

-----

State SHOULD be immutable. There should be a very atomic, functional-style programming applied to smart contracts.
SO many bugs/hacks come from shit people are doing with state that they shouldn't. So much admin managed state,
side effects, and similar things causing security issues. 

-----

Upgrades/Proxies:

The way that people are thinking about Proxies are so whack. There should be a single Proxy
contract serving as an api gateway and everything else is just a read/query layer than can be redirected by the gateway.
People trying to forward calls via delegate call through the state contract are insane.
Diamond standard as a standard makes sense but the naming/branding around it is just ridiculous.

Use a CQRS style contract architecture (separate reads/writes).

----

On testing:

Some Waffle matchers retuxrn a Promise rather than executing immediately. 
If you're making a call or sending a transaction, make sure to check 
Waffle's documentation, and await these Promises. Otherwise your tests 
may pass without waiting for all checks to complete.

----

TODO:
- Add events for logging purposes

IDEA:
- on launch of contracts, start at epoch 1. Fresh start. New DAO from beginning. Reset issuance.
- give all contributors/depositors tokens earned in the form of sDNT.
- let depositors decide: deposit in contract to earn sDNT, or walk away from the table full refund no questions asked + earned sDNT.
- set higher withdraw fee -> 20%? create locking mechanism for multipliers? 6mo, 12mo, 18mo?

IDEA: 

Referral Mining: 

- incentivized intros program: make intros to the dao mine referral bonuses
- referral is an onlyMember() that requires a certain # of tokens staked
  - only contributors/investors can feasibly mine


